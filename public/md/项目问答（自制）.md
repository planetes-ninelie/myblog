# 项目问答

## 1 关于商城管理系统

### 1 使用 vue3 + TypeScript框架，利用Vite构建项目

```
1.源码的升级
	使用proxy替代defineProperty
	重写虚拟DOM
2.更好支持typeSript

3.性能提升
	打包体积更小
	渲染速度更快
	内存减少
```

```
ts
ts是js的超集
```



### 2 利用 eslint+prettier 校验代码和格式化，husky实现代码提交检验

```
eslint针对的是javascript，他是一个检测工具，包含js语法以及少部分格式问题，在eslint看来，语法对了就能保证代码正常运行，格式问题属于其次；(检查js语法的)
prettier属于格式化工具，它看不惯格式不统一，所以它就把eslint没干好的事接着干。(格式化代码的)
husky在代码提交之前触发git hook(git在客户端的钩子)，然后执行`pnpm run format`来自动的格式化我们的代码
```



### 3 通过 elementplus 实现颜色主题自由切换，可切换暗黑模式或全屏模式

```
暗黑模式
1.引入element暗黑模式的css变量
2.在切换按钮中添加一个事件，当用户点击时，获取根节点html.document，根据开关情况，给根节点添加一个类名“dark”或者不添加类名""，也就是空类名
```

```
颜色主题
与暗黑模式类似
1.在html上写el-color-picker标签，也就是取色器，绑定color的值，当用户选取取色器的颜色变化结束时，会取rgb的值作为color的值
2.绑定change事件，当color值变化结束时，获取根节点html.document，根据color值通过html.style.setProperty()方法改变主题颜色


持久化如何做？
有些样式改不了如何解决？
```

```
全屏模式
1.获取document.fullscreenElement，也就一个dom对象的属性，根据这个属性来判断是否进如退出全屏模式
2.如果fullscreenElment不为真，则进入全屏模式，调用document.documentElement.requestFullscreen()
3.如果为真，则退出全屏模式，调用document.exitFullScreen()
```



### 4 利用Echarts 可视化，实现数据大屏，包括大地图、水球图和条形图等

```
基本步骤：
1.引入echarts组件，
2.创建图表容器，在HTML中创建一个具有一定尺寸的div容器，用于展示图表
3.初始化图表，使用Echarts提供的初始化方法，将图表容器和一个新创建的实例对象关联起来
	echarts.init()
4.配置图表参数，设置实例对象的option属性
5.渲染图表
	setOption()
```

```
title
tooltip
toolbox
markline
grid
series
xAxis
yAxis
```



### 5 对 axios 进行二次封装：使用请求拦截器给请求头添加 token ；使用响应拦截器，对返回数据状态码进行处理

```
import axios from 'axios'
import { ElMessage } from 'element-plus'
//引入用户相关的仓库
import useUserStore from '@/store/modules/user'
//1.创建axios实例
let request = axios.create({
  baseURL: import.meta.env.VITE_APP_BASE_API,
  timeout: 5000,
})
//2.请求拦截器
request.interceptors.request.use((config) => {
  //获取用户相关的小仓库
  let userStore = useUserStore()
  if (userStore.token) {
    config.headers.token = userStore.token
  }
  //返回配置对象
  return config
})
//3.响应拦截器
request.interceptors.response.use(
  (response) => {
    return response.data
  },
  (error) => {
    //处理网络错误
    let msg = ''
    let status = error.response.status
    switch (status) {
      case 401:
        msg = 'token过期'
        break
      case 403:
        msg = '无权访问'
        break
      case 404:
        msg = '请求地址错误'
        break
      case 500:
        msg = '服务器出现问题'
        break
      default:
        msg = '无网络'
    }
    ElMessage({
      type: 'error',
      message: msg,
    })
    return Promise.reject(error)
  },
)
export default request

```



### 6 路由守卫实现路由鉴权，根据 token 以及用户信息判断是否放行或路由跳转

```
//路由鉴全，项目当中路由能不能被访问权限的设置
import router from './router'
//引入进度条插件
import nprogress from 'nprogress'
//引入进度条样式
import 'nprogress/nprogress.css'
nprogress.configure({ showSpinner: false })
//获取用户相关的小仓库内部token数据
import useUserStore from './store/modules/user'
//引入大仓库
import pinia from './store'

import setting from './setting'

let userStore = useUserStore(pinia)

//全局前置守卫
router.beforeEach(async (to: any, from: any, next: any) => {
  document.title = setting.title + '-' + to.meta.title
  nprogress.start()
  let token = userStore.token
  let username = userStore.username
  if (token) {
    if (to.path == '/login') {
      next({ path: '/' })
    } else {
      if (username) {
        next()
      } else {
        try {
          await userStore.userInfo()
          next({ ...to, replace: true })
        } catch (error) {
          await userStore.userLogout()
          next({ path: '/login', query: { redirect: to.path } })
        }
      }
    }
  } else {
    if (to.path == '/login') {
      next()
    } else {
      next({ path: '/login', query: { redirect: to.path } })
    }
  }
})

//全局后置守卫
router.afterEach(() => {
  nprogress.done()
})

```



### 7 根据角色信息分配按钮的权限，按钮中利用 全局自定义指令 来处理权限问题

```
let userStore = useUserStore(pinia)
export const isHasButton = (app: any) => {
  //全局自定义指令
  app.directive('has', {
    mounted(el: any, options: any) {
      if (!userStore.buttons.includes(options.value)) {
        el.parentNode.removeChild(el)
      }
    },
  })
}
```



### 8 使用 pinia 进行状态管理，使得用户信息等各自独立，便于代码维护和管理





## 2 购物点单小程序

### **1.** **使用 vue3 + TypeScript**框架



### **2.** **对使用频率较低的订单模块和用户模块进行分包，缓解小程序加载压力**

```
作用：优化小程序下载和启动速度
	小程序启动默认下载主包并启动页面，当用户进入分包时，才会下载对应的分包，下载完进行展示
```



### **3.** **使用 uni 组件，获取屏幕边界到屏幕安全区域距离，实现样式适配**

```
//获取屏幕边界到安全区域距离
const { safeAreaInsets } = uni.getSystemInfoSync()
<view class="navbar" :style="{ paddingTop: safeAreaInsets?.top + 'px' }">
</view>
```



### **4.** **利用 pinia 实现数据持久化，存储个人信息和地址信息**

```
vuex和Pinia都是官方提供的状态管理库，我的项目使用的是Pinia进行全局状态管理。

先从vuex来说，我对vuex的了解呢，它是将全局状态集中管理，方便追踪状态变化。vuex主要有4个核心概念，分别是：state，getter，action，mutation。

state是用于储存全局状态

getter是用于state中派生出来一些状态，例如计算属性

mutation是用于同步修改state，严格遵循单向数据流

action用于异步操作，可以包含异步api请求，异步提交mutation

而pinia相当于vuex5，是一个轻量级、兼容vue3和vue2的状态管理库，pinia与vuex不同点在于废弃了mutation，pinia的核心概念是store，用来存储全局状态和处理状态变化的方法，类似vuex和state、getter和action的集合，可以创建和使用多个store实例，每个store都有自己独立的状态和方法

对于pinia的持久化存储方案，我用到了pinia-plugin-persistedstate插件实现，但是其默认使用localStorage实现持久化，小程序端不兼容，所以得改配置，替换为uni-app支持多段的持久化API，也就是uni.setStorageSync() 和 uni.getStorageSync( )。配置完后，就会自动将个人信息和地址信息保存在客户端，即使关闭小程序，数据依然可以保留

```

```
// 定义 Store
export const useMemberStore = defineStore(
  'member',
  () => {
    // 会员信息
    const profile = ref<LoginResult>()

    // 保存会员信息，登录时使用
    const setProfile = (val: LoginResult) => {
      profile.value = val
    }

    // 清理会员信息，退出时使用
    const clearProfile = () => {
      profile.value = undefined
    }

    // 记得 return
    return {
      profile,
      setProfile,
      clearProfile,
    }
  },
  // TODO: 持久化
  {
    persist: {
      storage: {
        setItem(key, value) {
          uni.setStorageSync(key, value)
        },
        getItem(key) {
          return uni.getStorageSync(key)
        },
      },
    },
  },
)
```



### **5.** **对部分页面实现骨架屏，等待页面加载时会出现，优化用户体验**

```
1.微信开发者工具里生成骨架屏
2.将生成的骨架屏代码放到新的vue文件中
3.在原vue页面的代码中，创建一个变量loading判断页面是否加载中，在onLoad生命周期函数中，先将变量loading设为true，再设为false
4.导入骨架屏的vue文件，在页面容器中调用该标签，令v-if的值等于loading，其余的div在v-else中

每个页面亦是如此
```



### **6. uniapp** **实现多端打包，并完成部分跨端样式兼容、组件兼容等**

```
1.条件编译，以 #ifdef + 平台名称 开头，#endif 结尾
2.小程序不支持 * 选择器
	页面视口差异
	H5端默认开启scoped
3.样式兼容例子：
	骨架屏在网页端显示有问题，然后在骨架屏的vue文件里添加条件编译引入相应样式，就是如果编译的是网页端的话就自动引入这些css样式，如果是小程序端就会引入，因为小程序端样式本身没有问题，只是网页端出现兼容问题
4.组件兼容例子：
	对于一些只有微信小程序才会生效的组件，比如button组件open-type=contact时，也就是小程序中才有的功能——联系客服按钮，这时候在网页端不需要，那这个组件就可以用条件编译了
```

