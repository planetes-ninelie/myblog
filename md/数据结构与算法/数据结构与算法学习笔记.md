# 数据结构与算法学习笔记

书名**《学习JavaScript数据结构与算法（第三版）》**

<u>斜体内容和心得为自己乱说的或是查资料的，非书上内容</u>

## 1 JavaScript简介

### 1.3 JavaScript基础

#### 1.3.2运算符

##### **1 运算符有：**

- 算术运算符
- 赋值运算符
- 比较运算符
- 逻辑运算符
- 位运算符
- 一元运算符
- 其他运算符

##### **2 算术运算符**

常见的有：`+`,`-`,`*`,`/`,`%`,`++`,`--`

##### **3 赋值运算符**

常见的有： `=`,`+=`,`-=`,`*=`,`/=`,``

*取余赋值的运算符，查了相关资料：[取余赋值（%=） - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Remainder_assignment)*

- ```
  let a = 3;
  
  a %= 2;//1
  a %= 0;//NaN
  a %= 'hello';//NaN
   
  ```

*而关于取余`%`，相关资料：[取余（%） - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Remainder)*

- 取余`%`：

  - 对于运算：`n % d`，其中 `n` 被称为被除数，`d` 被称为除数。如果**其中的任意一个**操作数为 `NaN`，或 `n` 为正负无穷（±Infinity），又或者 `d` 为 ±0，则该运算返回 `NaN`。否则，如果 `d` 为正负无穷（±Infinity），或 `n` 为 ±0，则返回被除数 `n`。

    - | 操作数          | 返回值 |
      | --------------- | ------ |
      | 其一操作数`NaN` | `NaN`  |
      | `n = ±Infinity` | `NaN`  |
      | `d = ±0`        | `NaN`  |
      | `d = ±Infinity` | `n`    |
      | `n = ±0`        | `n`    |

  - 示例
  
    - ```
      被除数为正数
      13 % 5; // 3
      1 % -2; // 1
      1 % 2; // 1
      2 % 3; // 2
      5.5 % 2; // 1.5
      
      被除数为负数
      -13 % 5; // -3
      -1 % 2; // -1
      -4 % 2; // -0
      
      被除数为 NaN
      NaN % 2; // NaN
      
      被除数为 Infinity
      Infinity % 2; // NaN
      Infinity % 0; // NaN
      Infinity % Infinity; // NaN
      2 % Infinity; // 2
      0 % Infinity; // 0
      ```

##### **4 比较运算符**

常见的有：`==`,`===`,`!=`,`>`,`>=`,`<`,`<=`

##### **5 逻辑运算符**

*逻辑运算符用于操作布尔值（真`true`或假`false`），通常用于条件判断*

| 逻辑运算符 | 描述       | 作用                                                         |
| ---------- | ---------- | ------------------------------------------------------------ |
| &&         | （逻辑）与 | *如果两个操作数都为真，则结果为真*                           |
| \|\|       | （逻辑）或 | *如果两个操作数中至少有一个为真，则结果为真*                 |
| !          | （逻辑）非 | *反转操作数的布尔值，即如果操作数为真，则结果为假；如果操作数为假，则结果为真。* |

##### 6 位运算符

*位运算符用于按二进制位进行操作，它们直接对整数的二进制表示进行操作*

| 位运算符 | 描述         | 作用                                                         |
| -------- | ------------ | ------------------------------------------------------------ |
| &        | （按位）与   | *当对应的两个比特都为1时，结果为1，否则为0*                  |
| \|       | （按位）或   | *当对应的两个比特中至少有一个为1时，结果为1，否则为0*        |
| ~        | （按位）非   | *将每个比特翻转，1变0，0变1*                                 |
| ^        | （按位）异或 | *当对应的两个比特不同时，结果为1，否则为0*                   |
| <<       | 左移         | *将一个数的所有比特向左移动指定的位数，高位丢弃，低位补零*   |
| >>       | 右移         | *将一个数的所有比特向右移动指定的位数，低位丢弃，高位通常由符号位填充（对于有符号整数）或补零（对于无符号整数）* |

#### 1.3.3 真值和假值

| 数值类型    | 转换或布尔值                                                 |
| ----------- | ------------------------------------------------------------ |
| `undefined` | `false`                                                      |
| `null`      | `false`                                                      |
| 布尔值      | true是`true`，false是`false`                                 |
| 数          | `+0`、`-0`和`NaN`都是`false`，其他都是`true`                 |
| 字符串      | 如果字符串是空的（长度是 0）就是 false，其他都是 true（长度大于等于 1） |
| 对象        | `true`                                                       |

#### 1.3.4 相等运算符（==和===）

##### **1 使用`==`**

| 类型x       | 类型y       | 结果                  |
| ----------- | ----------- | --------------------- |
| `null`      | `undefined` | `true`                |
| `undefined` | `null`      | `true`                |
| 数          | 字符串      | `x == toNumber(y)`    |
| 字符串      | 数          | `toNumber(x) == y`    |
| 布尔值      | 任何类型    | `toNumber(x) == y`    |
| 任何类型    | 布尔值      | `x == toNumber(y)`    |
| 字符串或数  | 对象        | `x == toPrimitive(y)` |
| 对象        | 字符串或数  | `toPrimitive(x) == y` |

如果 **x 和 y 的类型相同**，JavaScript 会用 **equals 方法**比较这两个值或对象。没有列在这个表格中的其他情况都会返回 `false`

*不清楚 equals 方法是什么，js中并没有原生的，反正MDN查不到，而通义千问上说：在JavaScript中，`equals`方法通常不是原生的`Number`, `String`, `Array`或`Object`类型的一部分。然而，你可以自己实现一个`equals`方法来比较两个对象是否相等，或者使用某些库（如Lodash）提供的`_.isEqual()`函数来进行深度比较*

*也就是说，与对象比调用`toPrimitive()`（说实话没看懂`toPrimitive()`），与数和字符串比先转化为数字*

##### **2 `toNumber` 方法**

| 值类型      | 结果                                                         |
| ----------- | ------------------------------------------------------------ |
| `undefined` | `NaN`                                                        |
| `null`      | `+0`                                                         |
| 布尔值      | 如果是 `true`，返回 `1`；如果是 `false`，返回`+0`            |
| 数          | 数对应的值                                                   |
| 对象        | 如果对象的 **valueOf** 方法的结果是**原始值**，返回原始值；如果对象的 **toString** 方法返回**原始值**，就返回这个值；其他情况都返回一个错误 |

**例子1：**

```
console.log('packt' ? true : false); // true
```

代码输出 true（字符串长度大于 1）

**例子2：**

```
console.log('packt' == true); //false
console.log('packt' == false);//false
```

用 toNumber 转换字符串值。因为字符串包含字母，所以会被转成 NaN。即`NaN == 1`和`NaN == 0`，结果都是`false`

*没看懂，toNumber方法没说清楚...例子1是怎么转化的，例子2又是怎么转化的...之后再去《现代JavaScript教程》里面细看吧*

*于是又想到其他例子：*

```
    console.log(NaN == undefined);  //false
    console.log(null == NaN); //false
    console.log(null == undefined); //true

    console.log(null == false); //false
    console.log(NaN == false);  //false
    console.log(undefined == false); //false
    //印证了前文提到的"没有列在这个表格中的其他情况都会返回false"
```



##### 3 使用 ===

- 如果比较的两个值类型不同，比较的结果就是 false

- 如果 比较的两个值类型相同，结果会根据下表判断

  - | 类型x  | 值                        | 结果 |
    | ------ | ------------------------- | ---- |
    | 数     | x和y的值相同（但不为NaN） | true |
    | 字符串 | x 和 y 是相同的字符       | true |
    | 布尔值 | x 和 y 都是 true 或 false | true |
    | 对象   | x 和 y 引用同一个对象     | true |

    

## 2 ECMAScript和TypeScript概述

略

## 3 数组

### 3.1 为什么用数组

*数组可以只用一个来管理多个变量*

### **3.2 创建和初始化数组**

1 创建方式有三种

```
let daysOfWeek = new Array(); // {1} 
daysOfWeek = new Array(7); // {2} 
daysOfWeek = new Array('Sunday', 'Monday', 'Tuesday', 'Wednesday', 
'Thursday', 'Friday', 'Saturday'); // {3} 
```

2 求斐波那契数列的前 20 个数

已知斐波那契数列中的前两项是 1， 从第三项开始，每一项都等于前两项之和

```
const fibonacci = []; 
fibonacci[1] = 1; 
fibonacci[2] = 1; 
for (let i = 3; i < 20; i++) { 
 	fibonacci[i] = fibonacci[i - 1] + fibonacci[i - 2];  
}
for (let i = 1; i < fibonacci.length; i++) { 
 	console.log(fibonacci[i]); 
} 
```

*没看明白就这个例子的用意是什么，是来说明for循环吗？还是用来介绍*`console.log()`

### **3.5 在任意位置添加或删除元素**

**`splice()`方法**

```
numbers.splice(5,3); 
```

这行代码删除了从数组索引 5 开始的 3 个元素。这就意味着 numbers[5]、numbers[6]和 numbers[7]从数组中删除了。

**tip**：对于 JavaScript 数组和对象，我们还可以用 **delete 运算符**删除数组中的元素，例如 delete numbers[0]。然而，数组位置 0 的值会**变成 undefined**，也就是说，以上操作等同于 numbers[0] = undefined。因此，我们应该始终使用 splice、pop 或 shift（马上就会学到）方法来删除数组元素。



```
numbers.splice(5, 0, 2, 3, 4); 
```

该splice 方法接收的

- **第一个参数**，表示想要删除或插入的元素的索引值。

- **第二个参数**是删除元素的个数（这个例子里，我们的目的不是删除元素，所以传入 0）。

- **第三个参数往后**，就是要 添加到数组里的值（元素 2、3、4）。输出会发现值又变成了从-3 到 12

*让我想到了slice()，用来截取原数组片段，但返回新的数组，不改变原有的数组*

### 3.6 二维和多维数组

JavaScript 只支持一维数组，并不支持矩阵，但是可以用数组套数组，实现矩阵或任一多维数组。

**tip：**要在浏览器控制台中打印二维数组，还可以使用 **console.table(averageTemp)** 语句。它会显示一个更加友好的输出结果。

*多维数组的迭代简单来说是通过嵌套for循环实现*

### 3.7 JavaScript 的数组方法参考

#### 3.7.1 方法一览：

| 方法        | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| concat      | 连接 2 个或更多数组，并返回结果                              |
| every       | 对数组中的每个元素运行给定函数，如果该函数对每个元素都返回 true，则返回 true |
| filter      | 对数组中的每个元素运行给定函数，返回该函数会返回 true 的元素组成的数组 |
| forEach     | 对数组中的每个元素运行给定函数。这个方法没有返回值           |
| join        | 将所有的数组元素连接成一个字符串                             |
| indexOf     | 返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1   |
| lastIndexOf | 返回在数组中搜索到的与给定参数相等的元素的索引里最大的值     |
| map         | 对数组中的每个元素运行给定函数，返回每次函数调用的结果组成的数组 |
| reverse     | 颠倒数组中元素的顺序，原先第一个元素现在变成最后一个，同样原先的最后一个元素变成了现在 的第一个 |
| slice       | 传入索引值，将数组里对应索引范围内的元素作为新数组返回       |
| some        | 对数组中的每个元素运行给定函数，如果任一元素返回 true，则返回 true |
| sort        | 按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数   |
| toString    | 将数组作为字符串返回                                         |
| valueOf     | 和 toString 类似，将数组作为字符串返回                       |

**ES2015 和 ES2016 新增的数组方法：**

| 方法       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| @@iterator | 返回一个包含数组键值对的迭代器对象，可以通过同步调用得到数组元素的**键值对** |
| copyWithin | 复制数组中一系列元素到同一数组指定的起始位置                 |
| entries    | 返回包含数组**所有键值对**的@@iterator                       |
| includes   | 如果数组中存在某个元素则返回 true，否则返回 false。ES2016 新增 |
| find       | 根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素 |
| findIndex  | 根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素在数组中的索引 |
| fill       | 用静态值填充数组                                             |
| from       | 根据已有数组创建一个新数组                                   |
| keys       | 返回包含数组所有索引的@@iterator                             |
| of         | 根据传入的参数创建一个新数组                                 |
| values     | 返回包含数组中所有值的@@iterator                             |

#### 3.7.**2 部分方法介绍**

**1 使用 for...of 循环迭代**

```
for (const n of numbers) { 
 console.log(n % 2 === 0 ? 'even' : 'odd'); 
} 
```

**2 使用@@iterator 对象**

```
let iterator = numbers[Symbol.iterator](); 
console.log(iterator.next().value); // 1 
console.log(iterator.next().value); // 2 
console.log(iterator.next().value); // 3 
console.log(iterator.next().value); // 4
```

```
iterator = numbers[Symbol.iterator](); 
for (const n of iterator) { 
 console.log(n); 
} 
```

**3 数组的entries**

```
let aEntries = numbers.entries(); // 得到键值对的迭代器
console.log(aEntries.next().value); // [0, 1] - 位置 0 的值为 1 
console.log(aEntries.next().value); // [1, 2] - 位置 1 的值为 2 
console.log(aEntries.next().value); // [2, 3] - 位置 2 的值为 3
```

**4 from 方法**

Array.from 方法根据已有的数组创建一个新数组。比如，要复制 numbers 数组，可以如 下这样做。

```
let numbers2 = Array.from(numbers);
```

还可以传入一个用来过滤值的函数：

```
let evens = Array.from(numbers, x => (x % 2 == 0));
```

**5 Array.of 方法**

Array.of 方法根据传入的参数创建一个新数组。以下面的代码为例

```
let numbers3 = Array.of(1); 
let numbers4 = Array.of(1, 2, 3, 4, 5, 6);
```

它和下面这段代码的效果一样

```
let numbers3 = [1]; 
let numbers4 = [1, 2, 3, 4, 5, 6];
```

我们也可以用该方法复制已有的数组：

```
let numbersCopy = Array.of(...numbers4);
```

它和下面这段代码的效果一样

```
Array.from(numbers4)
```

**6 fill方法**

fill 方法用静态值填充数组

```
let numbersCopy = Array.of(1, 2, 3, 4, 5, 6); 
numbersCopy.fill(0);  // [0, 0, 0, 0, 0, 0]

let numbersCopy = Array.of(0, 2, 2, 2, 2, 2); 
numbersCopy.fill(1, 3, 5); //[0, 2, 2, 1, 1, 2]

```

*简单来说，`fill(填入值，开始填入的索引，结束填入的索引（不包括本身）)`*

**7 copyWithin方法**

```
let copyArray = [1, 2, 3, 4, 5, 6];
copyArray.copyWithin(0, 3); //[4, 5, 6, 4, 5, 6]

copyArray = [1, 2, 3, 4, 5, 6];
copyArray.copyWithin(1, 3, 5); //[1, 4, 5, 4, 5, 6]
```

#### 3.7.3 排序 

##### **1 reverse() 反序**

```
numbers.reverse(); 
```

##### **2  sort()**

`sort()` 默认情况下，对数组做排序时，把元素默认成字符串进行相互比较

排序前：`[15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3,  2, 1]`

排序后：`[1, 10, 11, 12, 13, 14, 15, 2, 3, 4, 5, 6, 7, 8,  9]`

要是实现数字比较：（升序排序）

```
numbers.sort((a, b) => a - b)
```

##### **3 自定义排序**

```
const friends = [ 
 { name: 'John', age: 30 }, 
 { name: 'Ana', age: 20 }, 
 { name: 'Chris', age: 25 }, // ES2017 允许存在尾逗号
]; 
//比较对象属性的函数
function comparePerson(a, b) { 
 if (a.age < b.age) { 
 return -1; 
 } 
 if (a.age > b.age) { 
 return 1; 
 } 
 return 0; 
} 
console.log(friends.sort(comparePerson));
//Ana(20), Chris(25), John(30)
```

*对于比较函数的返回值，查阅了资料：*[Array.prototype.sort() - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#描述)

| `compareFn(a, b)` 返回值 | 排序顺序               |
| ------------------------ | ---------------------- |
| \> 0                     | a 在 b 前面            |
| < 0                      | b 在 a 前面            |
| === 0                    | 保持 a 和 b 原来的顺序 |

*为了确保正确的排序行为，比较函数应具有以下属性：*

- *纯函数：比较函数不会改变被比较的对象或任何外部状态。（这很重要，因为无法保证比较函数将在何时以及如何调用，因此任何特定的调用都不应对外部产生可见的效果。）*
- *稳定性：比较函数对于相同的输入对应始终返回相同的结果。*
- *自反性：`compareFn(a, a) === 0`。*
- *反对称性：`compareFn(a, b)` 和 `compareFn(b, a)` 必须都是 `0` 或者具有相反的符号。*
- *传递性：如果 `compareFn(a, b)` 和 `compareFn(b, c)` 都是正数、零或负数，则 `compareFn(a, c)` 的符号与前面两个相同。*

##### **4 字符串排序**

**根据字符对应的 ASCII 值来比较**：

"Ana", "John", "ana", "john"的值分别为：65、74、97、106

```
let names = ['Ana', 'ana', 'john', 'John']; 
console.log(names.sort()); 
//["Ana", "John", "ana", "john"]
```

给 sort 传入一个**忽略大小写的比较函数**，将输出["Ana", "ana", "John",  "john"]：

```
names = ['Ana', 'ana', 'john', 'John']; // 重置数组的初始状态
console.log(names.sort((a, b) => { 
 	if (a.toLowerCase() < b.toLowerCase()) { 
 		return -1; 
 	} 
 	if (a.toLowerCase() > b.toLowerCase()) { 
 		return 1; 
 	} 
 	return 0; 
})); 
//['Ana', 'ana', 'john', 'John']
```

tip：

- 在这种情况下，sort 函数不会有任何作用。它会按照现在的大小写字母顺序排序。*注意`'john', 'John'`的排序*

- *`toLowerCase()` 方法返回将字符串转换为小写形式后的值。`toLowerCase()` 不会影响字符串 `str` 本身的值。*
  * *查阅资料：[String.prototype.toLowerCase() - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase)*

如果希望**小写字母排在前面**，那么需要使用 **localeCompare** 方法：

```
names.sort((a, b) => a.localeCompare(b));
//["ana", "Ana", "john", "John"]
```

*tip:*

- *调用 [str.localeCompare(str2)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare) 会根据语言规则返回一个整数，这个整数能指示字符串 `str` 在排序顺序中排在字符串 `str2` 前面、后面、还是相同：*
  - *如果 `str` 排在 `str2` 前面，则返回负数。*
  - *如果 `str` 排在 `str2` 后面，则返回正数。*
  - *如果它们在相同位置，则返回 `0`。*
    - *资料来源：[字符串 (javascript.info)](https://zh.javascript.info/string#bi-jiao-zi-fu-chuan)*

假如对**带有重音符号的字符**做排序的话，也可以用 **localeCompare** 来实现:

```
const names2 = ['Maève', 'Maeve']; 
console.log(names2.sort((a, b) => a.localeCompare(b)));
//["Maeve", "Maève"]
```

#### 3.7.4 搜索

- indexOf 方法返回与参数匹配的第一个元素的索引

- lastIndexOf 返回 与参数匹配的最后一个元素的索引

- find 和 findIndex 方法接收一个回调函数，搜索一个满足回调函数条件的值。不同之处在于，find 方法**返回第一个满足条件的值**，findIndex 方法则**返回这个值在数组里的索引**。如果没有满足条件的值，find 会返回 **undefined**，而 findIndex 返回**-1**

- includes 方法，如果数组里存在某个元素，includes 方法会返回 true，否则返回 false。

  - 如果给 includes 方法传入一个起始索引，搜索会从索引指定的位置开始

    ```
    let numbers2 = [7,6,5,4,3,2,1]; 
    console.log(numbers2.includes(4,5));
    ```

    上面的例子输出为 false，因为数组索引 5 之后的元素不包含 4。

#### 3.7.5 输出数组为字符串

- toString 方法

  ```
  console.log(numbers.toString()); 
  ```

  把数组里所有元素输出为一个字符串

- join 方法

  ```
  const numbersString = numbers.join('-'); 
  console.log(numbersString);
  //1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-10
  ```

  - 用一个不同的分隔符（比如-）把元素隔开

  - 如果要把数组内容发送到服务器，或进行编码（知道了分隔符，解码也很容易），这会很有用

### 3.8 类型数组

使用 WebGL API、进行位操作、处理文件和图像时，类型数组都可以大展拳脚。它用起来和普通数组毫无二致，本章所学的数组方法和功能都可以用于类型数组。

https://www.html5rocks.com/en/tutorials/webgl/typed_arrays/是一个很好的教程，讲解了如何使 用类型数组处理二进制数据，以及它在实际项目中的应用。

*坏了，这个网站我进不去...*

### 3.9 TypeScript 中的数组

- TypeScript 会在编译时进行类型检测，来确保只对所有值都属于相同数据类型的数组进行操作

- 根据类型推断，TypeScript 能够理解 numbers 数组的声明和 const numbers: number[] 是一样的。出于这个原因，如果我们在声明时给变量赋了初始值，就**不需要每次都显式声明变量的类型**了。

- 例子：

  - 代码如下：

  ```
  interface Person { 
   	name: string; 
   	age: number; 
  } 
  // const friends: {name: string, age: number}[]; 
  const friends = [ 
  	{ name: 'John', age: 30 }, 
  	{ name: 'Ana', age: 20 }, 
  	{ name: 'Chris', age: 25 } 
  ]; 
  function comparePerson(a: Person, b: Person) { 
   // comparePerson 函数的内容
  }
  ```

  - 通过声明 Person 接口，我们确保了 comparePerson函数只接收包含 name 和 age 属性的 对象。
  - friends 数组没有显式的类型，因此可以在本例中通过 const friends: Person[]显 式声明它的类型。

- 如果想用 TypeScript 给 JavaScript 变量设置类型

  - 只需要使用 const 或 let  variableName: []
  - 或在使用.js 扩展名的文件时，在 第一行添加注释`// @ts-check`

## 4 栈

**引言：**

本质是一种具有特殊行为的数组

在数组的任意位置上删除或添加元素，然而还需要一种能在添加或删除元素时进行**更多控制**的数据结构，那就是**栈**和**队列**

本章内容包括：

- 创建我们自己的 JavaScript 数据结构库
- 栈数据结构
- 向栈添加元素
- 从栈移除元素
- 如何使用 Stack 类
- 十进制转二进制

### 4.1 创建一个 JavaScript 数据结构和算法库

代码包下载：[loiane/javascript-datastructures-algorithms: :books: collection of JavaScript and TypeScript data structures and algorithms for education purposes. Source code bundle of JavaScript algorithms and data structures book (github.com)](https://github.com/loiane/javascript-datastructures-algorithms)

在VSCode打开项目后，先`npm i`安装相应的包

在 `package.json` 文件中，你可以找到一条` npm run webpack `命令，它用来生成 `PacktDataStructuresAlgorithms.min.js` 文件

### 4.2 栈数据结构

#### **4.2.1 概念：**

- 栈是一种遵从**后进先出（LIFO）**原则的**有序**集合
- 新添加或待删除的元素都保存在栈的同一端，称作**栈顶**，另一端就叫**栈底**
- 在栈里，新元素都靠近栈顶，旧元素都接近栈底。
- 栈也被用在编程语言的编译器和内存中保存变量、方法调用等，也被用于浏览器历史记录 （浏览器的返回按钮）

*看完这个概念，联系前文说的“在添加或删除元素时更多控制‘，这个更多控制体现在哪呢？*

#### 4.2.2 创建一个基于数组的栈

**声明Stack类**：

```
    class Stack {
      constructor() {
        this.items = [];
      }
    } 
```

- 选择数组作为保存栈里的元素，数组允许我们在任何 位置添加或删除元素；
- 由于栈**遵循 LIFO 原则**，需要对元素的**插入和删除**功能进行**限制**

*看到这里，这个更多的控制不会是更多的限制吧，限制栈只对栈顶的元素进行操作*

- 为栈声明方法：
  - `push(element(s))`：添加一个（或几个）新元素到栈顶。 
  - `pop()`：移除栈顶的元素，同时返回被移除的元素。  
  - `peek()`：返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）
  - `isEmpty()`：如果栈里没有任何元素就返回 true，否则返回 false。
  - `clear()`：移除栈里的所有元素。 
  - `size()`：返回栈里的元素个数。该方法和数组的 length 属性很类似。

#### 4.2.3 向栈添加元素

```
push(element) { 
 this.items.push(element); 
} 
```



#### 4.2.4 从栈移除元素

```
pop() { 
 return this.items.pop(); 
} 
```



#### 4.2.5 查看栈顶元素

```
peek() { 
 return this.items[this.items.length - 1]; 
}
```



#### 4.2.6 检查栈是否为空

```
isEmpty() { 
 return this.items.length === 0; 
}
```



#### 4.2.7 清空栈元素

```
clear() { 
 this.items = []; 
}
```

也可以多次调用`pop()`

至此，栈已经实现！

#### 4.2.8 使用 Stack 类

深入了解栈的应用前，我们先来学习如何使用 Stack 类

首先需要初始化 Stack 类，然 后验证一下栈是否为空（输出是 true，因为还没有往栈里添加元素）

```
const stack = new Stack(); 
console.log(stack.isEmpty()); // 输出为 true

stack.push(5); 
stack.push(8);
console.log(stack.peek()); // 输出 8 

stack.push(11); 
console.log(stack.size()); // 输出 3 
console.log(stack.isEmpty()); // 输出 false

stack.pop(); 
stack.pop(); 
console.log(stack.size()); // 输出 2 
```



### 4.3 创建一个基于 JavaScript 对象的 Stack 类

基于js对象构建Stack类的原因：

- 能直接获取元素
- 占用较少的内存空间
- 保证所有元素按照我们的需要排列

数组的劣势：

- 大部分方法的时间复杂度是 O(n)。如果数组有更多元素的话，所需的时间会更长。
- 数组是元素的一个有序集合，为了保证元素排列有序，它会占用更多的内存空间。

#### 4.3.1 声明Stack.js类

```
class Stack { 
 	constructor() { 
 		this.count = 0; 
 		this.items = {}; 
 	} 
 	// 方法
} 
```



#### 4.3.2 向栈中插入元素

```
push(element) { 
 this.items[this.count] = element; 
 this.count++; 
} 
```



#### 4.3.3 验证一个栈是否为空和它的大小

```
size() { 
 return this.count; 
} 
isEmpty() { 
 return this.count === 0; 
} 
```



#### 4.3.4 从栈中弹出元素

```
pop() { 
 	if (this.isEmpty()) { // {1} 
 		return undefined; 
 	} 
 	this.count--; // {2} 
 	const result = this.items[this.count]; // {3} 
 	delete this.items[this.count]; // {4} 
 	return result; // {5} 
} 
```



#### 4.3.5 查看栈顶的值并将栈清空

```
peek() { 
	if (this.isEmpty()) { 
		return undefined; 
	} 
    return this.items[this.count - 1]; 
} 

clear() { 
    this.items = {}; 
    this.count = 0; 
} 

//清空的另一种方式
clear1() {
    while (!this.isEmpty()) { 
     	this.pop(); 
    }
}
```



#### 4.3.6 创建 toString 方法

```
toString() { 
	if (this.isEmpty()) { 
		return ''; 
	} 
	let objString = `${this.items[0]}`;  
	for (let i = 1; i < this.count; i++) {  
		objString = `${objString},${this.items[i]}`;
	} 
	return objString; 
}
```

*自己写的有很多问题，**错误例子：***

```
（自己写的）
toString() {
	let i = 0
	let result = ''
	while (i < this.count) {
  		result.concat(',', Object.prototype.toString(this.items[i]))
  		i++
}
	return result
}
```

*通义千问给出的评价是寄：*

1. ***结果字符串的构建**： 在循环中使用 `result.concat()` 是不正确的，因为 `concat()` 方法会返回一个新的字符串，并不会修改原字符串。你应该使用 `+=` 或者 `.push()`（如果使用数组）来累积字符串。*
3. ***Object.prototype.toString 的使用**： 使用 `Object.prototype.toString.call(this.items[i])` 可以得到一个描述对象类型的字符串，例如 "[object Array]"、"[object String]" 等。然而，这可能不是你想要的结果，因为你可能只是想将 `this.items[i]` 转换为字符串形式。*

```
（通义千问的修改）
toString() {
  let result = '';
  for (let i = 0; i < this.count; i++) {
    // 将每个元素转换为其字符串表示形式
    result += ',' + String(this.items[i]);
  }
  return result.trim(); // 去除前导空格
}
```

tip:除了 toString 方法，我们创建的其他方法的复杂度均为 O(1)，代表我们可以 直接找到目标元素并对其进行操作（push、pop 或 peek）

### 4.4 保护数据结构内部元素

#### 4.4.1 原因

我们在 Stack 类中声明的 items 和 count 属性并没有得到保护：

```
const stack = new Stack(); 
console.log(Object.getOwnPropertyNames(stack)); // {1} 
console.log(Object.keys(stack)); // {2} 
console.log(stack.items); // {3} 

```

行{1}和行{2}的输出结果是["count", "items"]。这表示 count 和 items 属性是公开的，我们可以像行{3}那样直接访问它们。根据这种行为，我们可以对这两个属性赋新的值。

#### 4.4.2 下划线命名约定

一部分开发者喜欢在 JavaScript 中使用下划线命名约定来标记一个属性为**私有属性**。

```
class Stack { 
	constructor() { 
		this._count = 0; 
		this._items = {}; 
	} 
} 
```

不过这种方式只是一种约定，并 不能保护数据，而且只能依赖于使用我们代码的开发者所具备的常识。

#### 4.4.3 用 ES2015 的限定作用域 Symbol 实现类

Symbol：ES2015 新增的基本类型，它是**不可变的**，可以用作对象的属性。

```
const _items = Symbol('stackItems'); // {1} 
class Stack { 
	constructor () { 
		this[_items] = []; // {2} 
	} 
// 栈的方法
} 
```

在上面的代码中，我们声明了 Symbol 类型的变量\_items（行{1}），在类的 constructor 函数中初始化它的值（行{2}）。要访问\_items，只需要把所有的 this.items 都换成 this[_items]。

这种方法创建了一个**假的私有属性**，因为 ES2015 新增的 `Object.getOwnPropertySymbols` 方法能够取到类里面声明的所有 Symbols 属性。下面是一个**破坏 Stack 类的例子**:

```
const stack = new Stack(); 
stack.push(5); 
stack.push(8); 
let objectSymbols = Object.getOwnPropertySymbols(stack); 
console.log(objectSymbols.length); // 输出 1 
console.log(objectSymbols); // [Symbol()] 
console.log(objectSymbols[0]); // Symbol() 
stack[objectSymbols[0]].push(1); 
stack.print(); // 输出 5, 8, 1 
```

从以上代码可以看到，访问 `stack[objectSymbols[0]]`是可以得到_items 的。并且， _items 属性是一个数组，可以**进行任意的数组操作**，比如从中间删除或添加元素（使用对象进行存储也是一样的）。但我们操作的是栈，**不应该出现这种行为**。

#### 4.4.4 用 ES2015 的 WeakMap 实现类

WeakMap是可以确保属性是私有的数据类型，可以储存键值对，其中键是对象，值是任意数据类型。

*读到这里突然不理解了，对象不就是键值对吗，那键又是键值对？看样子理解出问题了，先往下看看再说*

如果用 WeakMap 来存储 items 属性（数组版本），Stack 类就是这样的：

*这里用“如果”一词就很有意思，难道说WeakMap类不是用来实现Stack类最好的数据类型吗？*

```
const items = new WeakMap(); // {1} 
class Stack { 
 	constructor () { 
 		items.set(this, []); // {2} 
 	} 
 	push(element){ 
 		const s = items.get(this); // {3} 
 		s.push(element); 
	} 
 	pop(){ 
 		const s = items.get(this); 
 		const r = s.pop(); 
 		return r; 
 	} 
	// 其他方法
} 
```

行{2}，在 constructor 中，以 this（Stack 类自己的引用）为键，把代表栈的数组存入 items

*这下似懂非懂，猜测items本身存放键值对，而键值对里的键也是个键值对？具体内容还得看第八章*

**items** 在 Stack 类里是**真正的私有属性**。采用这种方法，代码的**可读性不强**，而且在扩展该类时**无法继承私有属性**。鱼和熊掌不可兼得！

#### 4.4.5 ECMAScript 类属性提案

TypeScript 提供了一个给类属性和方法使用的 **private 修饰符**。然而，该修饰符**只在编译时有用**（包括我们在前几章讨论的 TypeScript 类型和错误检测）。在代码被转移完成后，属性同样是公开的。

*也就是说private修饰符几乎没啥用？*

事实上，我们**不能像在其他编程语言**中一样声明**私有**属性和方法。虽然有很**多种方法**都可以达到**相同的效果**，但无论是在语法还是性能层面，这些方法都有各自的优点和缺点。

我们可以通过在属性前**添加井号（#）**作为前缀来**声明私有属性**。这种行为和 WeakMap 中的私有属性很**相似**。所以在不远的未来，我们有希望不使用特殊技巧或牺牲代码可读性，就能使用私有类属性。

```
class Stack { 
	#count = 0; 
	#items = 0; 
	// 栈的方法
}
```

*所以说4.4整一小节，说了个寂寞？介绍了几种方式保护内部元素，但都不是最完美的；不过，用`#`作为前缀来声明私有属性比起前面用`_`作为前缀（4.4.2）似乎还是有点用。*

### 4.5 用栈解决问题

栈的实际**应用非常广泛**。在**回溯问题**中，它可以**存储访问过的任务或路径、撤销的操作**（后面的章节讨论图和回溯问题时，我们会学习如何应用这个例子）。Java 和 C#用栈来存储变量和方法调用，特别是**处理递归算法**时，有可能抛出一个**栈溢出异常**（后面的章节也会介绍）。 

*处理递归算法可能会出现栈溢出异常，也就是说会无限循环？*

既然我们已经了解了 **Stack 类**的用法，不妨用它来解决一些**计算机科学问题**。本节，我们将介绍如何解决**十进制转二进制问题**，以及**任意进制转换**的算法。

#### 4.5.1 从十进制到二进制

书上做法：

```
function decimalToBinary(decNumber) { 
 	const remStack = new Stack(); 
 	let number = decNumber; 
 	let rem; 
 	let binaryString = ''; 
 	while (number > 0) {
 		rem = Math.floor(number % 2); 
 		remStack.push(rem); // {3} 
 		number = Math.floor(number / 2); 
 	} 
 	while (!remStack.isEmpty()) { 
 		binaryString += remStack.pop().toString(); 
 	} 
 	return binaryString; 
} 
```

*自己的做法：思路大致一致，需改进的是while的条件应该是`temp >0`，而`temp >= 1`忽略了为`0`的情况是输出`0`的。不仅如此，整个代码如果输入`0`会得不到结果，所以需要分类讨论或者修改while循环里的代码*

```
    （自己写的）
    function decimalToBinary(num) {
      let stack = new Stack()
      let temp = num
      while (temp >= 1) {
        re = temp % 2
        stack.push(re)
        temp = Math.floor(temp / 2)
      }
      let result = stack.toString().split(',').reverse().join('')
      return result
    }
```

*改进版本：*

```
    （自己写的）
    function decimalToBinary(num) {
      let stack = new Stack()
      let temp = num
      if (temp == 0) stack.push(temp)
      while (temp >= 1) {
        re = temp % 2
        stack.push(re)
        temp = Math.floor(temp / 2)
      }
      let result = stack.toString().split(',').reverse().join('')
      return result
    
```



#### 4.5.2 进制转换算法

```
function baseConverter(decNumber, base) { 
 	const remStack = new Stack(); 
 	const digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; // {6} 
 	let number = decNumber; 
 	let rem; 
 	let baseString = ''; 
 	if (!(base >= 2 && base <= 36)) { 
 		return ''; 
 	} 
 	while (number > 0) { 
 		rem = Math.floor(number % base); 
 		remStack.push(rem); 
		number = Math.floor(number / base); 
 	}
 	while (!remStack.isEmpty()) { 
 		baseString += digits[remStack.pop()]; // {7} 
 	} 
 return baseString; 
}
```

我们只需要改变一个地方。在将十进制转成二进制时，余数是 0 或 1；在将十进制转成八进制时，余数是 0～7；但是将十进制转成十六进制时，余数是 0～9 加上 A、B、C、D、E 和 F（对 应 10、11、12、13、14 和 15）。因此，我们需要**对栈中的数字做个转化**才可以（行{6}和行{7}）。 因此，从十一进制开始，字母表中的每个字母将表示相应的基数。字母 A 代表基数 11，B 代表基数 12，以此类推。



## 5 队列和双端队列

队列和栈非常类似，但是使用了与**后进先出**不同的原则。你将在本章学习这些内容。我们同样要学习**双端队列**的工作原理。双端队列是一种将**栈的原则和队列的原则混合**在一起的数据结构。

本章包括：

- 队列数据结构
- 双端队列数据结构
- 向队列和双端队列增加元素
- 从队列和双端队列中删除元素
- 用击鼓传花游戏模拟循环队列
- 用双端队列检查一个词组是否构成回文

### 5.1 队列数据结构

队列是遵循**先进先出**（**FIFO**，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。

*后进先出是LIFO*

#### 5.1.1 创建队列

```
class Queue { 
	constructor() { 
 		this.count = 0; // {1} 
 		this.lowestCount = 0; // {2} 
 		this.items = {}; // {3} 
 	} 
}  
```

声明一个 **`count`** 属性来帮助我们**控制队列的大小**（行{1}）。此外，由于我们将要从队列前端移除元素，同样需要一个变量来帮助我们**追踪第一个元素**。因此，声明一个 **`lowestCount`** 变量（行{2}）

**声明可用的方法：**

- enqueue(element(s))：向队列尾部添加一个（或多个）新的项。
- dequeue()：移除队列的第一项（即排在队列最前面的项）并返回被移除的元素。
- peek()：返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做 任何变动（不移除元素，只返回元素信息——与 Stack 类的 peek 方法非常类似）。该方 法在其他语言中也可以叫作 front 方法。
- isEmpty()：如果队列中不包含任何元素，返回 true，否则返回 false。
- size()：返回队列包含的元素个数，与数组的 length 属性类似。

##### 1 向队列添加元素

```
enqueue(element) { 
 	this.items[this.count] = element; 
 	this.count++; 
}
```

*向`items`添加了元素之后才让`count`自增，也就是说`items[this.count]`上是空的*

##### 2 从队列移除元素

```
dequeue() { 
 	if (this.isEmpty()) { 
 		return undefined; 
 	} 
 	const result = this.items[this.lowestCount]; // {1} 
 	delete this.items[this.lowestCount]; // {2} 
 	this.lowestCount++; // {3} 
 	return result; // {4} 
} 
```

##### 3 查看队列头元素

```
peek() { 
 	if (this.isEmpty()) { 
 		return undefined; 
 	} 
 	return this.items[this.lowestCount]; 
} 

```

##### 4 检查队列是否为空并获取它的长度

```
isEmpty() { 
 	return this.count - this.lowestCount === 0; 
} 
size() { 
 	return this.count - this.lowestCount; 
} 
isEmpty() { 
 	return this.size() === 0; 
}
```

##### 5 清空队列

```
clear() { 
     this.items = {}; 
     this.count = 0; 
     this.lowestCount = 0; 
} 
```

##### 6 创建 toString 方法

```
toString() { 
 	if (this.isEmpty()) { 
 		return ''; 
 	} 
 	let objString = `${this.items[this.lowestCount]}`; 
 	for (let i = this.lowestCount + 1; i < this.count; i++) { 
 		objString = `${objString},${this.items[i]}`; 
 } 
 	return objString; 
}
```

**tip：**Queue 类和 Stack 类非常类似。主要的区别在于 **dequeue** 方法和 **peek** 方法， 这是由于先进先出和后进先出原则的不同所造成的。



#### 5.1.2 使用 Queue 类

```
const queue = new Queue(); 
console.log(queue.isEmpty()); // 输出 true 

queue.enqueue('John'); 
queue.enqueue('Jack'); 
console.log(queue.toString()); // John,Jack

queue.enqueue('Camila');

console.log(queue.toString()); // John, Jack, Camila 
console.log(queue.size()); // 输出 3 
console.log(queue.isEmpty()); // 输出 false 
queue.dequeue(); // 移除 John 
queue.dequeue(); // 移除 Jack 
console.log(queue.toString()); // Camila
```



### 5.2 双端队列数据结构

**双端队列**（deque，或称 **double**-ended queue）是一种允许我们同时从前端和后端添加和移除元素的特殊队列

在计算机科学中，双端队列的一个常见应用是存储一系列的撤销操作。

#### 5.2.1 创建 Deque 类

```
class Deque { 
     constructor() { 
         this.count = 0; 
         this.lowestCount = 0; 
         this.items = {}; 
     } 
} 
```

方法：

- addFront(element)：该方法在双端队列前端添加新的元素。 
- addBack(element)：该方法在双端队列后端添加新的元素（实现方法和 Queue 类中的 enqueue 方法相同）。 
- removeFront()：该方法会从双端队列前端移除第一个元素（实现方法和 Queue 类中的 dequeue 方法相同）。
- removeBack()：该方法会从双端队列后端移除第一个元素（实现方法和 **Stack** 类中的 pop 方法一样）。 
- peekFront()：该方法返回双端队列前端的第一个元素（实现方法和 Queue 类中的 peek 方法一样）。
- peekBack()：该方法返回双端队列后端的第一个元素（实现方法和 **Stack** 类中的 peek 方法一样）。

*就如书上所说，将栈的原则和队列的原则混合*

```
//该方法在双端队列前端添加新的元素
addFront(element) { 
     if (this.isEmpty()) { // {1} 
     	this.addBack(element); 
     } else if (this.lowestCount > 0) { // {2} 
     	this.lowestCount--; 
     	this.items[this.lowestCount] = element; 
     } else { 
     	for (let i = this.count; i > 0; i--) { // {3} 
     		this.items[i] = this.items[i - 1]; 
     } 
     this.count++; 
     this.lowestCount = 0; 
     this.items[0] = element; // {4} 
     } 
} 
```

- 第一种场景是这个双端队列是**空**的（行{1}）。在这种情况下，我们可以执行 **addBack** 方法。 元素会被添加到双端队列的后端，在本例中也是双端队列的前端。addBack 方法已经有了增加 count 属性值的逻辑，因此我们可以复用它来避免重复编写代码。

- 第二种场景是一个元素已经被从双端队列的前端移除（行{2}），也就是说 **lowestCount 属性会大于等于 1**。这种情况下，我们只需要将 **lowestCount 属性减 1 并将新元素的值放在这个键的位置上即可**。

  - 考虑如下所示的 Deque 类的内部值。

  ```
  items = { 
   1: 8, 
   2: 9 
  }; 
  count = 3; 
  lowestCount = 1; 
  ```

  如果我们想将元素 7添加在双端队列的前端，那么符合第二种场景。在本示例中，lowestCount 的值会减少（新的值是 0），并且 7 会成为键 0 的值。

- 第三种也是最后一种场景是 **lowestCount 为 0** 的情况。我们可以**设置一个负值的键**，同时更新用于计算双端队列长度的逻辑，使其也能包含负键值。这种情况下，添加一个新元素的操作仍然能保持最低的计算成本。为了便于演示，我们把本场景看作使用数组。要在第一位添加一个新元素，我们需要将**所有元素后移一位**（行{3}）来**空出第一个位置**。由于我们不想丢失任何已有的值，需要从最后一位开始迭代所有的值，并为元素赋上索引值减 1 位置的值。在所有的元素 都完成移动后，第一位将是空闲状态，这样就可以用需要添加的新元素来覆盖它了（行{4}）。



### 5.3 使用队列和双端队列来解决问题

#### 5.3.1 循环队列——击鼓传花游戏

```
function hotPotato(elementsList, num) { 
 	const queue = new Queue(); // {1} 
 	const eliminatedList = []; 
 	for (let i = 0; i < elementsList.length; i++) { 
 		queue.enqueue(elementsList[i]); // {2} 
 } 
 	while (queue.size() > 1) { 
 		for (let i = 0; i < num; i++) { 
 			queue.enqueue(queue.dequeue()); // {3} 
 		} 
 		eliminatedList.push(queue.dequeue()); // {4} 
 	} 
 	return { 
 		eliminated: eliminatedList, 
 		winner: queue.dequeue() // {5} 
 	}; 
} 

```

*看过大致思路自己写了一遍，发现代码几乎一致，不同的是`return`部分：*

```
return { eliminatedList, winner: queue.peek() }
```

*因为`eliminatedList`键值相同，所以我省略了冒号后面。而`winner`书上写的是`queue.dequeue()`，利用删除队头返回删除值的方法实现，而我写的是`queue.peek()`，利用查看队头元素的方法实现，因为`queue`里就只剩最后一个元素了。*

测试方法：

```
const names = ['John', 'Jack', 'Camila', 'Ingrid', 'Carl']; 
const result = hotPotato(names, 7); 
result.eliminated.forEach(name => { 
 	console.log(`${name}在击鼓传花游戏中被淘汰。`); 
}); 
console.log(`胜利者： ${result.winner}`); 
```



#### 5.3.2 回文检查器

书上的写法：

```
function palindromeChecker(aString) { 
 if (aString === undefined || aString === null || 
 (aString !== null && aString.length === 0)) { // {1} 
 return false; 
 } 
 const deque = new Deque(); // {2} 
 const lowerString = aString.toLocaleLowerCase().split(' ').join(''); // {3} 
 let isEqual = true; 
 let firstChar, lastChar; 
 for (let i = 0; i < lowerString.length; i++) { // {4} 
 deque.addBack(lowerString.charAt(i)); 
 } 
 while (deque.size() > 1 && isEqual) { // {5} 
 firstChar = deque.removeFront(); // {6} 
 lastChar = deque.removeBack(); // {7} 
 if (firstChar !== lastChar) { 
 isEqual = false; // {8} 
 } 
 } 
 return isEqual; 
} 
```

*我的写法：*

```
    function palindromeChecker(aString) {
      let deque = new Deque()
      if (aString === undefined || aString === null || aString.length === 0) return false
      aString.toLocaleLowerCase().split(' ').join('').split('').forEach(item => deque.addFront(item))
      while (deque.size() > 1) {
        if (deque.removeFront() !== deque.removeBack()) return false
      }
      return true
    }
```

*一开始的版本：*

- *我忽略了`aString`为`undefined``null`或者长度为0的情况*
- *忽略了大小写的情况*
- *忽略了空格的情况，空格应当去掉*

#### 5.3.3 JavaScript 任务队列

当我们在浏览器中打开新标签时，就会创建一个**任务队列**。这是因为每个标签都是**单线程**处理所有的任务，称为**事件循环**。浏览器要**负责多个任务**，如渲染 HTML、执行 JavaScript 代码、 处理用户交互（用户输入、鼠标点击等）、执行和处理异步请求。如果想更多地了解事件循环， 可以访问 https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/。



## 6 链表

链表这种**动态**的数据结构，可以从中随意**添加或移除项**，它会按需进行扩容

内容包括：

- 链表数据结构 
- 向链表添加元素
- 从链表移除元素
- 使用 LinkedList 类
- 双向链表 
- 循环链表 
- 排序链表 
- 通过链表实现栈

### 6.1 链表数据结构

#### 6.1.1 概念

要**存储多个元素**，数组（或列表）可能是最常用的数据结构。正如本书之前提到的，每种语言都实现了数组。这种数据结构非常方便，提供了一个便利的[]语法来访问其元素。然而，这种 数据结构有一个**缺点**：（在大多数语言中）**数组的大小是固定的**，从数组的起点或中间插入或移除项的成本很高，因为**需要移动元素**。（尽管我们已经学过，JavaScript 有来自 Array 类的方法 可以帮我们做这些事，但背后的情况同样如此。）

*简单来说，数组除了在尾端插入之外的插入需要移动元素，大小也固定，这是数组的缺点，因此我们才需要用到链表*

链表存储**有序的元素集合**，但不同于数组，链表中的元素在内存中并**不是连续放置的**。每个元素由一个存储元素**本身的节点**和一个**指向下一个元素的引用**（也称指针或链接）组成。下图展示了一个链表的结构。

*内存中不是连续的好理解，就是这些数据或变量在物理内存地址上并非紧挨着存储。那什么叫有序的元素集合？有序的元素集合是指其中的元素按照某种规则排列的数据结构。*

![image-20240719190919568](https://fastly.jsdelivr.net/gh/planetes-ninelie/assets/image-20240719190919568.png)

相对于传统的数组，链表的一个好处在于，添加或移除元素的时候**不需要移动其他元素**。然而，链表需要使用**指针**，因此实现链表时需要额外注意。在数组中，我们可以直接访问任何位置的任何元素，而要想**访问**链表中间的一个元素，则需要**从起点**（表头）开始**迭代**链表直到找到所需的元素。



#### 6.1.2 创建链表

```
    //两变量是否相等的方法
    function defaultEquals(a, b) {
      return a === b;
    }
    //node类
    class Node {
      constructor(element) {
        this.element = element;
        this.next = undefined
      }
    }
    class LinkedList {
      constructor(equalsFn = defaultEquals) {
        this.count = 0;
        this.head = undefined;
        this.equalsFn = equalsFn;
      }
    }
```

*没想明白`this.equalsFn = equalsFn;`的作用*

*为什么要比较链表中的元素是否相等*？

#### 6.1.3 向链表尾部添加元素

```
push(element) { 
 	const node = new Node(element); // {1} 
 	let current; // {2} 
 	if (this.head == null) { // {3} 
 		this.head = node; 
 	} else { 
 		current = this.head; // {4} 
 		while (current.next != null) { // {5} 获得最后一项
 			current = current.next; 
 		} 
 	// 将其 next 赋为新元素，建立链接
 		current.next = node; // {6} 
 	} 
 	this.count++; // {7} 
}
```

tip1：链表最后一个节点的下一个元素始终是 undefined 或 null。

*null的情况是尾部被删除后的情况吗？*

tip2：

- `this.head == null`（行{3}）和`(this.head === undefined || head === null)`等价，

- `current.next != null`（ 行{5}） 和`(current.next !==  undefined && current.next !== null)`等价。
- 当一个 Node 实例被创建时，它的 next 指针总是 undefined。这没问题，因为我们知道它 会是链表的最后一项。
- 当然，别忘了递增链表的长度，这样就能控制它并且轻松得到链表的长度

测试目前数据结构：

```
const list = new LinkedList(); 
list.push(15); 
list.push(10); 
```

#### 6.1.4 从链表中移除元素

```
removeAt(index) { 
 // 检查越界值
 if (index >= 0 && index < this.count) { // {1} 
 let current = this.head; // {2} 
 // 移除第一项
 if (index === 0) { // {3} 
 this.head = current.next; 
 } else { 
 let previous; // {4} 
 for (let i = 0; i < index; i++) { // {5} 
 previous = current; // {6} 
 current = current.next; // {7} 
 } 
 // 将 previous 与 current 的下一项链接起来：跳过 current，从而移除它
 previous.next = current.next; // {8} 
 } 
 this.count--; // {9} 
 return current.element; 
 } 
 return undefined; // {10} 
} 
```



### 6.2 双向链表



### 6.3 循环链表



### 6.4 有序链表



### 6.5 创建 StackLinkedList 类



### 6.6 小结

链表相比数组最重要的优点， 那就是**无须移动**链表中的元素，就能**轻松**地**添加和移除元素**。

因此，当你需要添加和移除**很多**元素时，最好的选择就是链表，而非数组。



## 7 集合

引言：集合是**不允许值重复**的**顺序**数据结构

```
心得：
也就是说集合里的每一个值都是独一无二的，数学中的集合有三个特性（查百度百科的）：确定性、互异性、无序性

对于确定性：给定一个集合和一个元素，该元素要么属于这个集合要么不属于；对于互异性：也就是不允许值重复，正如数据结构定义集合这一概念那样；对于无序性：元素之间是无序的，没有必然的序

至于为什么说是顺序数据结构，还得接下去看
```

通过本章内容会学习到：

- 如何创建集合这种数据结构，以及增删查（*“改”为什么没有呢*）
- 如何用set进行数学运算（并集、交集、差集运算）
- 使用ECMAScript2015（ES2015）原生的set类

### 7.1  构建数据集合

- 集合是由一组**无序**且**唯一**的**项**组成的，该数据结构使用了与**有限集合**相同的数学概念

  ```
  心得：
  这么说，数据结构中的集合 = 数学中的有限集合
  那在数学概念中，什么是有限集合？
  百度百科上提到：
  
  有限集合是由有限个元素组成的集合，也称有穷集合。
  
  1、单元素集合：只含一个元素的集合是一种特殊的有限集合。
  2、非空集合：至少含有一个元素的集合。(不一定是有限集合)
  3、空集：不含任何元素的集合，空集只有一个，用“{}”或者“Φ”表示。空集是一切集合的子集。
  ```

### 7.2 创建集合类

引言：

定义Set类

```
class Set {
	constructor() {
		this.items = {};
	}
}
```

使用对象{}的原因：JavaScript 的对象不允许一个key(属性)指向两个不同的属性，保证了集合里的元素都是唯一的。

*对象{}中，键值对是唯一的，如果尝试给同一个对象添加具有相同键的多个属性，后面的赋值会覆盖前面的值*

接下来声明一些集合可用的方法(模拟ES2015实现Set类)：

```
add(element)：向集合添加一个新元素
delete(element)：从集合移除一个元素
has(element)：如果元素在集合中，返回 true，否则返回 false
clear()：移除集合中的所有元素
size()：返回集合所包含元素的数量。它与数组的 length 属性类似
values()：返回一个包含集合中所有值（元素）的数组
```

#### 7.2.1 has(element)方法

##### **1 为什么要先实现这个方法呢？**

因为它会被add、delete等其他方法调用。

*万一添加的值集合里就有相同的了，那岂不是违背集合的规则了嘛；又或者删除的值在集合里不存在，难道说虚空删值嘛？*

#####  **2 代码实现：**

```
has(element) {
	return element in this.items;
}
```

*我一开始的想法竟然是将目标值与集合的值一个个匹配，如果匹配了就返回true，否则false。这样写起来似乎有点麻烦了，不过有疑惑的就是element匹配的是对象中的key还是value，我觉得是key*

```
自己的想法（虽然烂，但是独属于自己的思考）
forEach()、map()、some()、find()是用在数组的，对象中使用不了,不过可以利用Object.keys()遍历key的数组

has(element) {
    return Object.keys(this.items).some((item) => item == element)
}

注意点：
1.“==”不能写成“===”，因为Object.keys()返回的是字符串string，并非数字number
2.some()里的箭头函数，如果要写两行，记得带上return
```

*写代码过程中，也发现自己对Object没理解透，比如Object静态方法和实例方法的区别：*

*1.静态方法：*

- *直接定义给构造函数的方法。*

- *静态方法使用"类名.方法名"去调用，但是构造函数所创建的实例不可以调用静态方法*

```
自己的理解
function Person (){}

Person.sayHello = function(){   // 这种形式定义的是静态方法
    console.log("Hello!");
}

var p1 = new Person();
console.log(p1);    // Object{ }
Person.sayHello();  // Hello!
p1.sayHello();      // 报错，Person里面的sayHello方法就是静态方法，创建的实例不可以调用，一调用就会报错。而构造函数本身可以调用。
```

*tip：new操作符做了什么?*

*(改变this指向比较关键，使得new出来的实例没有办法获取静态方法）*

```
function create(fn, ...args) {
  var obj = {}; //创建了一个空对象
  Object.setPrototypeOf(obj,fn.prototype); //.将空对象的对象原型指向构造函数的原型对象
  var result = fn.apply(obj,args)//将空对象作为构造函数的上下文（改变this指向）
  return result instanceof Object ? result: obj;//对构造函数有返回值的处理判断，若原始值为对象返回原始值，否则正常处理
}
```

*2.实例方法：*

- *在构造函数上用this指向新创建的实例。*

- *每个实例在创建时都会定义该方法，每个实例的该方法都是自己特有的，不与其它实例共有。*

```
function Person (){
    this.sayHello = function(){   // 这种形式定义的sayHello就是实例方法
        console.log("Hello!");
    }
}
 
var p1 = new Person();
console.log(p1);    // Object { sayHello: sayHello() }
Person.sayHello();  //报错，构造函数未定义该方法，用this定义的该方法只是给实例定义的，只有实例可以调用
p1.sayHello();      //实例可以调用，输出"Hello!"
 
var p2 = new Person();
console.log(p2);
p2.sayHello();
console.log(p1.sayHello == p2.sayHello);   // false
console.log(p1.sayHello === p2.sayHello);  // 输出false，每个实例在创建时都会定义sayHello方法，每个实例的该方法都是自己特有的，不与其它实例共有，所以每个实例的该方法不是同一个。
```

*3.原型方法：*

- *是定义在构造函数的原型对象上的方法，是所有实例公共的方法*
- *创建实例的**构造函数却不可以调用原型方法**，但是可以利用(obj).prototype.(function)*

```
    function Person (name){
      this.name = name
    }
 
    Person.prototype.sayHello = function(){    // 定义的是原型方法
        console.log("Hello!" + this.name);
    }
    
    var p1 = new Person("p1");
    p1.sayHello();  //实例可以调用原型方法，输出："Hello!p1"
    //Person.sayHello("proto");  //报错，构造函数不可调用它自己原型上的方法，只有它创建的实例可以调用它原型上的方法
    
    // 这一行代码实际上是无效的，因为它试图像调用普通函数一样去调用Person.prototype.sayHello
    // 但是，原型方法需要通过一个具体的对象实例来调用，而不是直接通过原型对象
    // 因此，这行代码会导致一个TypeError，因为sayHello方法期望在this上下文中有一个name属性，而直接通过Person.prototype调用时，this会被设置为全局对象（在浏览器中通常是window），它可能没有name属性
    Person.prototype.sayHello("proto"); //"Hello!undefined"
    
    var p2 = new Person("p2");
    p2.sayHello();  //"Hello!p2"
    
    //比较的是方法引用
    console.log(p1.sayHello == p2.sayHello);  // "true"
    console.log(p1.sayHello === p2.sayHello); // "true"  因为是在构造函数的原型上定义的方法，每个实例本身并没有该方法，实例调用的给方法均来自于原型上的，每个实例调用的都是同一个
    //比较的是方法返回的结果
    console.log(p1.sayHello() == p2.sayHello()); // "Hello!p1" "Hello!p2" "true"   
    console.log(p1.sayHello() === p2.sayHello());// "Hello!p1" "Hello!p2" "true"   


//很神奇的就是输入进去的“p1”和“p2"怎么看都不相同，但是在原型上定义的方法被调用之后，不同实例调用的原型方法竟然是相等的，不过似乎知道原因了，再创建新的构造方法试试

    function Person (name){
      this.name = name
    }

    Person.prototype.sayHello = function(){    // 定义的是原型方法
      return(this.name);
    }

    var p1 = new Person("p1");
    console.log(p1.sayHello());
    
    var p2 = new Person("p2");
    console.log(p2.sayHello());

    //比较的是方法引用
    console.log(p1.sayHello == p2.sayHello);  // "true"
    console.log(p1.sayHello === p2.sayHello); // "true" 

    //比较的是方法返回的结果
    console.log(p1.sayHello() == p2.sayHello()); // "false"   
    console.log(p1.sayHello() === p2.sayHello());// "false" 

```

*参考资料：[静态方法、实例方法和原型方法_什么是静态方法和实例方法-CSDN博客](https://blog.csdn.net/qiuqiula_/article/details/100138750)*



回到代码实现（前文提到的）：

```
has(element) {
	return element in this.items;
}
```

in 运算符则返回表示对象在原型链上是否有特定属性的布尔值。

下面有更好的实现方式：

```
has(element) { 
 return Object.prototype.hasOwnProperty.call(this.items, element); 
} 
```

Object 原型有 hasOwnProperty 方法。该方法返回一个表明对象是否具有特定属性的布尔值。

tip：

我们也可以在代码中使用 this.items.hasOwnProperty(element)。但是，如果这样的话，代码检查工具如 ESLint 会抛出一个**错误**。错误的原因为**不是所有的对象都继承了 Object.prototype**，甚至继承了 Object.prototype 的对象上的 **hasOwnProperty 方法也有可能被覆盖**，导致代码不能正常工作。要避免出现任何问题，使用 Object.prototype.hasOwnProperty.call 是更安全的做法

*通义千问上说：*

*对于“**不是所有的对象都继承了 Object.prototype**”*

*在JavaScript中，当你创建一个对象，如果不指定原型链，默认情况下，这个对象会继承自 `Object.prototype`。然而，你可以通过 `Object.create(null)` 或者某些框架/库提供的类似功能**创建一个不继承自 `Object.prototype` 的对象**。这样的对象不会拥有 `hasOwnProperty`, `toString`, `valueOf` 等默认的方法，因为这些方法都是定义在 `Object.prototype` 上的。*

*对于“**hasOwnProperty 可能被覆盖**”*

*即使一个对象确实继承了 `Object.prototype`，它的 `hasOwnProperty` 方法仍然有可能被覆盖。覆盖**意味着原始的方法被替换成了不同的实现**，这可能是有意为之的，也可能是无意中发生的。当 `hasOwnProperty` 被覆盖时，原本的实现就不再可用，这可能导致代码逻辑出错。*

*对于**"使用 `Object.prototype.hasOwnProperty.call`"***

*为了避免上述两种情况导致的问题，可以使用 `Object.prototype.hasOwnProperty.call`。这种方式确保你总是**调用了未被覆盖的原始 `hasOwnProperty` 方法**。这是因为 `call` 方法允许你指定一个上下文对象（`this` 值），并且确保你调用的是 `Object.prototype` 上的那个 `hasOwnProperty` 方法，而不是对象自己可能有的覆盖版本。*



#### 7.2.2 add方法

**实现方法：**

```
add(element) { 
     if (!this.has(element)) { 
         this.items[element] = element; 
         return true; 
     } 
        return false; 
} 
```

tip：添加一个 element 的时候，把它同时作为键和值保存，因为这样有利于查找该元素

#### 7.2.3 delete和clear方法

**1 下面要实现 delete 方法**

```
delete(element) { 
 	if (this.has(element)) { 
 		delete this.items[element]; 
 		// delete是运算符，从items对象中移除属性
 		return true; 
	} 
 	return false; 
}
```

**2 实现clear方法**

```
clear() { 
	this.items = {}; 
}
```

**3 this.items变量**

例子：Object {1: 1, 2: 2} 

属性名就是添加到集合的值，同时它也是属性值

#### **7.2.4 size方法**

**1 第一种方式：**

是使用一个 length 变量，每当使用 add 或 delete 方法时就控制它，就像在之 前的章节中使用 LinkedList、Stack 和 Queue 类一样。

**2 第二种方式：**

使用 JavaScript 中 Object 类的一个内置方法。

```
size() { 
 	return Object.keys(this.items).length;  
}; 
```

**3 第三种方式：**

```
sizeLegacy() { 
     let count = 0; 
     for(let key in this.items) { 
     	if(this.items.hasOwnProperty(key)) {
     		count++;
     	} 
     return count; 
}; 
```

*为什么要弄这么麻烦？直接for...in...计数不就好了。但是，for...in...语句迭代items对象的属性还包含了额外的属性（如继承Object类的属性），不仅仅只有我们所添加的值*

#### **7.2.5 values方法**

**1 实现1：**

```
values() { 
	return Object.values(this.items); 
} 
```

Object.values()方法返回了一个包含给定对象所有属性值的数组。它是在 ECMAScript 2017 中被添加进来的，**目前只在现代浏览器中可用**。

**2 实现2**：

```
valuesLegacy() { 
	let values = []; 
 	for(let key in this.items) { // {1} 
 		if(this.items.hasOwnProperty(key)) { 
 			values.push(key); // {2} 
 		} 
 	} 
 	return values; 
};
```

#### 7.2.6 使用Set类

```
const set = new Set(); 
set.add(1); 
console.log(set.values()); // 输出[1] 
console.log(set.has(1)); // 输出 true 
console.log(set.size()); // 输出 1 
set.add(2); 
console.log(set.values()); // 输出[1, 2] 
console.log(set.has(2)); // 输出 true 
console.log(set.size()); // 输出 2 
set.delete(1); 
console.log(set.values()); // 输出[2] 
set.delete(2); 
console.log(set.values()); // 输出[] 
```

### 7.3 集合运算

引言：

1. SQL 联接的基础就是集合运算
2. 有以下运算：

- 并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合
- 交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。
- 差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集 合的元素的新集合

- 子集：验证一个给定集合是否是另一集合的子集

#### 7.3.1 并集

**1 实现：**

```
union(otherSet) { 
 	const unionSet = new Set(); 
 	this.values().forEach(value => unionSet.add(value)); 
 	otherSet.values().forEach(value => unionSet.add(value)); 
 	return unionSet; 
}
```

tip：**forEach 方法** 和 **箭头函数（=>）** 来代替显式声明 function(value) { unionSet.add(value) }是 ECMAScript 2015 中 引入的。

<u>*forEach和for...in的区别是什么？*</u>

*这样是否可行？*

```
（自己写的）
  union1(otherSet) {
    const unionSet = new Set();
    for (let key in this.items) {
      unionSet.add(this.items[key])
    }
    for (let key in otherSet.items) {
      unionSet.add(otherSet.items[key])
    }
    return unionSet;
  }
```



不使用 forEach 方法和箭头函数时：

```
union(otherSet) { 
 const unionSet = new Set(); 
 let values = this.values();  
 for (let i = 0; i < values.length; i++){ 
  unionSet.add(values[i]); 
 } 
 values = otherSet.values();
 for (let i = 0; i < values.length; i++){ 
  unionSet.add(values[i]); 
 } 
 return unionSet; 
};
```

tip：本章实现的 union、intersection 和 difference 方法**不会修改当前的 Set 类实例**或是**作为参数传入的 otherSet**。**没有副作用**的方法和函数被称为**纯函数**。纯函数不会修改当前的实例或参数，只会生成一个新的结果。

#### 7.3.2 交集 

**1 实现方法：**

```
intersection(otherSet) { 
 	const intersectionSet = new Set(); 
	const values = this.values(); 
 	for (let i = 0; i < values.length; i++) { 
 		if (otherSet.has(values[i])) {
     		intersectionSet.add(values[i]); 
     	} 
 	} 
 	return intersectionSet; 
} 

```

*没想到自己写的和书上的思路几乎一致：*

```
 （自己写的）
  intersection(otherSet) {
    const intersectionSet = new Set()
    this.values().forEach((value) => {
      if (otherSet.has(value)) {
        intersectionSet.add(value)
      }
    })
    return intersectionSet
  }
```

**2 改进方法**

*在两集合匹配之前，先找长度较短的集合来迭代，这样可以减少循环次数，提高效率*

书上这样实现：

```
intersection(otherSet) { 
 	const intersectionSet = new Set(); 
 	const values = this.values();
 	const otherValues = otherSet.values();
 	let biggerSet = values;
 	let smallerSet = otherValues; 
 	if (otherValues.length - values.length > 0) {
 		biggerSet = otherValues; 
 		smallerSet = values; 
 	} 
 	smallerSet.forEach(value => {
 		if (biggerSet.includes(value)) { 
 			intersectionSet.add(value); 
 		} 
 	}); 
 	return intersectionSet; 
} 
```

*自己写的（有趣的是，书上的改进办法除了减少迭代次数，还将for循环改为forEach，与前面我自己写的一致）：*

```
（自己写的，个人感觉语义化没书上的好）
      intersection(otherSet) {
        const intersectionSet = new Set()
        let temp1 = this.values()
        let temp2 = otherSet.values()
        if (temp2 < temp1) {
          temp1 = otherSet.values()
          temp2 = this.values()
        }
        temp1.forEach((value) => {
          if (otherSet.has(value)) {
            intersectionSet.add(value)
          }
        })
        return intersectionSet
      }
```

#### 7.3.3 差集

**1 实现：**

```
difference(otherSet) { 
 	const differenceSet = new Set();
 	this.values().forEach(value => { 
 		if (!otherSet.has(value)) { 
 			differenceSet.add(value); 
 		} 
 	}); 
 	return differenceSet; 
}
```

*感觉和交集的实现方式差不多，就不写了，变的是if判断集合里是否存在另一个集合里的值。不过不能按照交集改进思路来写，因为用不同集合作为forEach的迭代，会有不同的结果，书上也是大概这么个意思：*

我们不能像优化 intersection 方法一样优化 difference 方法，因为 setA 与 setB 之间的差集可能和 setB 与 setA 之间的差集不同



#### 7.3.4 子集

实现：

```
isSubsetOf(otherSet) { 
 	if (this.size() > otherSet.size()) { 
 		return false; 
 	} 
 	let isSubset = true; 
 	this.values().every(value => {
 		if (!otherSet.has(value)) {
 			isSubset = false; 
 			return false; 
 		} 
 		return true; 
 	}); 
 	return isSubset;  
} 
```

*一开始自己写的是forEach循环，并且true和false用错了，在forEach返回的true和false不是给整个isSubsetOf()的，而是forEach本身的，但是forEach本身是没有返回值，**以下是错误示范**：*

```
 （自己写的）
 isSubsetOf(otherSet) {
    this.values().forEach((value) => {
      if (!otherSet.has(value)) {
        return false
      }
    })
    return true
  }
```

*后来又想到了利用计数的方式，只要计数的结果不等于集合值的长度就返回false，否则true（不知道这个算法对不对，不过简单测试了一下没问题，但运行速度应该要比书上的慢）*

```
  （自己写的）
  isSubsetOf(otherSet) {
    let count = 0
    this.values().forEach((value) => {
      if (otherSet.has(value)) {
        count++
      }
    })
    console.log(count);
    if (count === this.values().length) {
      return true
    } else {
      return false
    }
  }
```



### 7.4 set类（ES6）

ECMAScript 2015 新增了 Set 类作为 JavaScript API 的一部分。我们可以基于 ES2015 的 Set 开发我们的 Set 类。

tip：关于 ECMAScript 2015 中 Set 类的实现细节，请查阅 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set

**1 来测试 Set 类的例子：**

```
const set = new Set(); 
set.add(1); 
console.log(set.values()); // 输出@Iterator 
console.log(set.has(1)); // 输出 true 
console.log(set.size); // 输出 1 
```

和原来的 Set 不同是，

- ES2015 的 Set 的 values 方法返回 Iterator（第 3 章提到过），而不是值构成的数组。

- 我们实现的 size 方法返回 set 中存储的值的个数，而 ES2015 的 Set 则有一个 size 属性。

- ES2015 原生的 Set 并没有了并集、交集、差集、子集等数学运算

**2 使用拓展运算符**

**并集计算**

```
console.log(new Set([...setA, ...setB])); 
```

​	tip：集合中每种值只会有一个

**交集计算**

```
console.log(new Set([...setA].filter(x => setB.has(x))));
```

**差集计算**

```
console.log(new Set([...setA].filter(x => !setB.has(x))));
```

### 7.5 多重集或袋

集合数据结构**不允许存在重复**的元素。但是，在数学中，有一个叫作**多重集**的概念，它允许我们向集合中插入之前已经添加过的元素。**多重集（或袋）**在计算集合中元素的**出现次数**时很有用。它也在数据库系统中得到了广泛运用

