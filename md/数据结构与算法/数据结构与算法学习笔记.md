# 数据结构与算法学习笔记

书名**《学习JavaScript数据结构与算法（第三版）》**

<u>斜体内容为自己乱说的，非书上内容</u>

## 1 JavaScript简介

## 2 ECMAScript和TypeScript概述

## 3 数组

## 4 栈

## 5 队列和双端队列

## 6 链表

## 7 集合

引言：集合是**不允许值重复**的**顺序**数据结构

```
心得：
也就是说集合里的每一个值都是独一无二的，数学中的集合有三个特性（查百度百科的）：确定性、互异性、无序性

对于确定性：给定一个集合和一个元素，该元素要么属于这个集合要么不属于；对于互异性：也就是不允许值重复，正如数据结构定义集合这一概念那样；对于无序性：元素之间是无序的，没有必然的序

至于为什么说是顺序数据结构，还得接下去看
```

通过本章内容会学习到：

- 如何创建集合这种数据结构，以及增删查（*“改”为什么没有呢*）
- 如何用set进行数学运算（并集、交集、差集运算）
- 使用ECMAScript2015（ES2015）原生的set类

### 7.1  构建数据集合

- 集合是由一组**无序**且**唯一**的**项**组成的，该数据结构使用了与**有限集合**相同的数学概念

  ```
  心得：
  这么说，数据结构中的集合 = 数学中的有限集合
  那在数学概念中，什么是有限集合？
  百度百科上提到：
  
  有限集合是由有限个元素组成的集合，也称有穷集合。
  
  1、单元素集合：只含一个元素的集合是一种特殊的有限集合。
  2、非空集合：至少含有一个元素的集合。(不一定是有限集合)
  3、空集：不含任何元素的集合，空集只有一个，用“{}”或者“Φ”表示。空集是一切集合的子集。
  ```

### 7.2 创建集合类

引言：

定义Set类

```
class Set {
	constructor() {
		this.items = {};
	}
}
```

使用对象{}的原因：JavaScript 的对象不允许一个key(属性)指向两个不同的属性，保证了集合里的元素都是唯一的。

*对象{}中，键值对是唯一的，如果尝试给同一个对象添加具有相同键的多个属性，后面的赋值会覆盖前面的值*

接下来声明一些集合可用的方法(模拟ES2015实现Set类)：

```
add(element)：向集合添加一个新元素
delete(element)：从集合移除一个元素
has(element)：如果元素在集合中，返回 true，否则返回 false
clear()：移除集合中的所有元素
size()：返回集合所包含元素的数量。它与数组的 length 属性类似
values()：返回一个包含集合中所有值（元素）的数组
```

#### 7.2.1 has(element)方法

##### **1 为什么要先实现这个方法呢？**

因为它会被add、delete等其他方法调用。

*万一添加的值集合里就有相同的了，那岂不是违背集合的规则了嘛；又或者删除的值在集合里不存在，难道说虚空删值嘛？*

#####  **2 代码实现：**

```
has(element) {
	return element in this.items;
}
```

*我一开始的想法竟然是将目标值与集合的值一个个匹配，如果匹配了就返回true，否则false。这样写起来似乎有点麻烦了，不过有疑惑的就是element匹配的是对象中的key还是value，我觉得是key*

```
自己的想法（虽然烂，但是独属于自己的思考）
forEach()、map()、some()、find()是用在数组的，对象中使用不了,不过可以利用Object.keys()遍历key的数组

has(element) {
    return Object.keys(this.items).some((item) => item == element)
}

注意点：
1.“==”不能写成“===”，因为Object.keys()返回的是字符串string，并非数字number
2.some()里的箭头函数，如果要写两行，记得带上return
```

*写代码过程中，也发现自己对Object没理解透，比如Object静态方法和实例方法的区别：*

*1.静态方法：*

- *直接定义给构造函数的方法。*

- *静态方法使用"类名.方法名"去调用，但是构造函数所创建的实例不可以调用静态方法*

```
自己的理解
function Person (){}

Person.sayHello = function(){   // 这种形式定义的是静态方法
    console.log("Hello!");
}

var p1 = new Person();
console.log(p1);    // Object{ }
Person.sayHello();  // Hello!
p1.sayHello();      // 报错，Person里面的sayHello方法就是静态方法，创建的实例不可以调用，一调用就会报错。而构造函数本身可以调用。
```

*tip：new操作符做了什么?*

*(改变this指向比较关键，使得new出来的实例没有办法获取静态方法）*

```
function create(fn, ...args) {
  var obj = {}; //创建了一个空对象
  Object.setPrototypeOf(obj,fn.prototype); //.将空对象的对象原型指向构造函数的原型对象
  var result = fn.apply(obj,args)//将空对象作为构造函数的上下文（改变this指向）
  return result instanceof Object ? result: obj;//对构造函数有返回值的处理判断，若原始值为对象返回原始值，否则正常处理
}
```

*2.实例方法：*

- *在构造函数上用this指向新创建的实例。*

- *每个实例在创建时都会定义该方法，每个实例的该方法都是自己特有的，不与其它实例共有。*

```
function Person (){
    this.sayHello = function(){   // 这种形式定义的sayHello就是实例方法
        console.log("Hello!");
    }
}
 
var p1 = new Person();
console.log(p1);    // Object { sayHello: sayHello() }
Person.sayHello();  //报错，构造函数未定义该方法，用this定义的该方法只是给实例定义的，只有实例可以调用
p1.sayHello();      //实例可以调用，输出"Hello!"
 
var p2 = new Person();
console.log(p2);
p2.sayHello();
console.log(p1.sayHello == p2.sayHello);   // false
console.log(p1.sayHello === p2.sayHello);  // 输出false，每个实例在创建时都会定义sayHello方法，每个实例的该方法都是自己特有的，不与其它实例共有，所以每个实例的该方法不是同一个。
```

*3.原型方法：*

- *是定义在构造函数的原型对象上的方法，是所有实例公共的方法*
- *创建实例的**构造函数却不可以调用原型方法**，但是可以利用(obj).prototype.(function)*

```
    function Person (name){
      this.name = name
    }
 
    Person.prototype.sayHello = function(){    // 定义的是原型方法
        console.log("Hello!" + this.name);
    }
    
    var p1 = new Person("p1");
    p1.sayHello();  //实例可以调用原型方法，输出："Hello!p1"
    //Person.sayHello("proto");  //报错，构造函数不可调用它自己原型上的方法，只有它创建的实例可以调用它原型上的方法
    
    // 这一行代码实际上是无效的，因为它试图像调用普通函数一样去调用Person.prototype.sayHello
    // 但是，原型方法需要通过一个具体的对象实例来调用，而不是直接通过原型对象
    // 因此，这行代码会导致一个TypeError，因为sayHello方法期望在this上下文中有一个name属性，而直接通过Person.prototype调用时，this会被设置为全局对象（在浏览器中通常是window），它可能没有name属性
    Person.prototype.sayHello("proto"); //"Hello!undefined"
    
    var p2 = new Person("p2");
    p2.sayHello();  //"Hello!p2"
    
    //比较的是方法引用
    console.log(p1.sayHello == p2.sayHello);  // "true"
    console.log(p1.sayHello === p2.sayHello); // "true"  因为是在构造函数的原型上定义的方法，每个实例本身并没有该方法，实例调用的给方法均来自于原型上的，每个实例调用的都是同一个
    //比较的是方法返回的结果
    console.log(p1.sayHello() == p2.sayHello()); // "Hello!p1" "Hello!p2" "true"   
    console.log(p1.sayHello() === p2.sayHello());// "Hello!p1" "Hello!p2" "true"   


//很神奇的就是输入进去的“p1”和“p2"怎么看都不相同，但是在原型上定义的方法被调用之后，不同实例调用的原型方法竟然是相等的，不过似乎知道原因了，再创建新的构造方法试试

    function Person (name){
      this.name = name
    }

    Person.prototype.sayHello = function(){    // 定义的是原型方法
      return(this.name);
    }

    var p1 = new Person("p1");
    console.log(p1.sayHello());
    
    var p2 = new Person("p2");
    console.log(p2.sayHello());

    //比较的是方法引用
    console.log(p1.sayHello == p2.sayHello);  // "true"
    console.log(p1.sayHello === p2.sayHello); // "true" 

    //比较的是方法返回的结果
    console.log(p1.sayHello() == p2.sayHello()); // "false"   
    console.log(p1.sayHello() === p2.sayHello());// "false" 

```

*参考资料：[静态方法、实例方法和原型方法_什么是静态方法和实例方法-CSDN博客](https://blog.csdn.net/qiuqiula_/article/details/100138750)*



回到代码实现（前文提到的）：

```
has(element) {
	return element in this.items;
}
```

in 运算符则返回表示对象在原型链上是否有特定属性的布尔值。

下面有更好的实现方式：

```
has(element) { 
 return Object.prototype.hasOwnProperty.call(this.items, element); 
} 
```

Object 原型有 hasOwnProperty 方法。该方法返回一个表明对象是否具有特定属性的布尔值。

tip：

我们也可以在代码中使用 this.items.hasOwnProperty(element)。但是，如果这样的话，代码检查工具如 ESLint 会抛出一个**错误**。错误的原因为**不是所有的对象都继承了 Object.prototype**，甚至继承了 Object.prototype 的对象上的 **hasOwnProperty 方法也有可能被覆盖**，导致代码不能正常工作。要避免出现任何问题，使用 Object.prototype.hasOwnProperty.call 是更安全的做法

*通义千问上说：*

*对于“**不是所有的对象都继承了 Object.prototype**”*

*在JavaScript中，当你创建一个对象，如果不指定原型链，默认情况下，这个对象会继承自 `Object.prototype`。然而，你可以通过 `Object.create(null)` 或者某些框架/库提供的类似功能**创建一个不继承自 `Object.prototype` 的对象**。这样的对象不会拥有 `hasOwnProperty`, `toString`, `valueOf` 等默认的方法，因为这些方法都是定义在 `Object.prototype` 上的。*

*对于“**hasOwnProperty 可能被覆盖**”*

*即使一个对象确实继承了 `Object.prototype`，它的 `hasOwnProperty` 方法仍然有可能被覆盖。覆盖**意味着原始的方法被替换成了不同的实现**，这可能是有意为之的，也可能是无意中发生的。当 `hasOwnProperty` 被覆盖时，原本的实现就不再可用，这可能导致代码逻辑出错。*

*对于**"使用 `Object.prototype.hasOwnProperty.call`"***

*为了避免上述两种情况导致的问题，可以使用 `Object.prototype.hasOwnProperty.call`。这种方式确保你总是**调用了未被覆盖的原始 `hasOwnProperty` 方法**。这是因为 `call` 方法允许你指定一个上下文对象（`this` 值），并且确保你调用的是 `Object.prototype` 上的那个 `hasOwnProperty` 方法，而不是对象自己可能有的覆盖版本。*



#### 7.2.2 add方法

